use iced::widget::{column, container, text, row, button, Space};
use iced::{Element, Length, Theme, Size, window, Event};
use iced::alignment::{Horizontal, Vertical};
use iced::keyboard::{self, Key};
use std::sync::Arc;

mod time_travel;
mod rpc_client;
mod event_handler;
mod debugger_ui;
mod swarm_monitor;
mod swarm_handler;

use time_travel::{TimeTravelState, TimeTravelMessage};
use debugger_ui::{DebuggerUiState, DebuggerMessage};
use rpc_client::GuiRpcClient;
use event_handler::EventHandler;
use descartes_daemon::DescartesEvent;
use swarm_monitor::{SwarmMonitorState, SwarmMonitorMessage};
use swarm_handler::{GuiStreamHandler, generate_sample_agents};

fn main() -> iced::Result {
    tracing_subscriber::fmt()
        .with_env_filter("descartes_gui=debug,info")
        .init();

    tracing::info!("Starting Descartes GUI");

    iced::application("Descartes", DescartesGui::update, DescartesGui::view)
        .subscription(DescartesGui::subscription)
        .window(window::Settings {
            size: Size::new(1200.0, 800.0),
            position: window::Position::Centered,
            min_size: Some(Size::new(800.0, 600.0)),
            ..Default::default()
        })
        .theme(|_| Theme::TokyoNight)
        .run_with(|| (DescartesGui::new(), iced::Task::none()))
}

/// Main application state
struct DescartesGui {
    /// Current view/tab
    current_view: ViewMode,
    /// Connection status to daemon
    daemon_connected: bool,
    /// Connection error message
    connection_error: Option<String>,
    /// Time travel debugger state
    time_travel_state: TimeTravelState,
    /// Debugger UI state
    debugger_ui_state: DebuggerUiState,
    /// Swarm monitor state
    swarm_monitor_state: SwarmMonitorState,
    /// RPC client (wrapped in Arc for cloning)
    rpc_client: Option<Arc<GuiRpcClient>>,
    /// Event handler
    event_handler: Option<Arc<tokio::sync::RwLock<EventHandler>>>,
    /// Recent events received
    recent_events: Vec<DescartesEvent>,
    /// Status message
    status_message: Option<String>,
}

/// Different views/modes in the application
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ViewMode {
    Dashboard,
    TaskBoard,
    SwarmMonitor,
    Debugger,
    DagEditor,
    ContextBrowser,
}

/// Messages that drive the application
#[derive(Debug, Clone)]
enum Message {
    /// Switch to a different view
    SwitchView(ViewMode),
    /// Connect to daemon
    ConnectDaemon,
    /// Connection result
    ConnectionResult(Result<(), String>),
    /// Disconnect from daemon
    DisconnectDaemon,
    /// Daemon event received
    DaemonEvent(DescartesEvent),
    /// Time travel debugger message
    TimeTravel(TimeTravelMessage),
    /// Debugger UI message
    Debugger(DebuggerMessage),
    /// Swarm monitor message
    SwarmMonitor(SwarmMonitorMessage),
    /// Load sample history data for demo
    LoadSampleHistory,
    /// Load sample swarm data for demo
    LoadSampleSwarm,
    /// Clear status message
    ClearStatus,
    /// Show error message
    ShowError(String),
    /// Timer tick for animations
    Tick,
}

impl DescartesGui {
    /// Create a new application instance
    fn new() -> Self {
        Self {
            current_view: ViewMode::Dashboard,
            daemon_connected: false,
            connection_error: None,
            time_travel_state: TimeTravelState::default(),
            debugger_ui_state: DebuggerUiState::default(),
            swarm_monitor_state: SwarmMonitorState::default(),
            rpc_client: None,
            event_handler: None,
            recent_events: Vec::new(),
            status_message: Some("Welcome to Descartes GUI! Click 'Connect' to connect to the daemon.".to_string()),
        }
    }
}

impl DescartesGui {
    fn update(&mut self, message: Message) -> iced::Task<Message> {
        match message {
            Message::SwitchView(view) => {
                tracing::debug!("Switching view to: {:?}", view);
                self.current_view = view;
                iced::Task::none()
            }
            Message::ConnectDaemon => {
                tracing::info!("Connecting to daemon");
                self.status_message = Some("Connecting to daemon...".to_string());
                self.connection_error = None;

                // Create RPC client
                match GuiRpcClient::default() {
                    Ok(client) => {
                        let client = Arc::new(client);
                        self.rpc_client = Some(Arc::clone(&client));

                        // Create event handler
                        let mut event_handler = EventHandler::default();
                        self.event_handler = Some(Arc::new(tokio::sync::RwLock::new(event_handler)));

                        // Perform async connection
                        iced::Task::perform(
                            async move {
                                match client.connect().await {
                                    Ok(_) => Ok(()),
                                    Err(e) => Err(e.to_string()),
                                }
                            },
                            Message::ConnectionResult,
                        )
                    }
                    Err(e) => {
                        self.connection_error = Some(format!("Failed to create RPC client: {}", e));
                        self.status_message = None;
                        iced::Task::none()
                    }
                }
            }
            Message::ConnectionResult(result) => {
                match result {
                    Ok(_) => {
                        tracing::info!("Successfully connected to daemon");
                        self.daemon_connected = true;
                        self.connection_error = None;
                        self.status_message = Some("Connected to daemon successfully!".to_string());
                    }
                    Err(e) => {
                        tracing::error!("Failed to connect to daemon: {}", e);
                        self.daemon_connected = false;
                        self.connection_error = Some(e);
                        self.status_message = None;
                        self.rpc_client = None;
                        self.event_handler = None;
                    }
                }
                iced::Task::none()
            }
            Message::DisconnectDaemon => {
                tracing::info!("Disconnecting from daemon");
                self.daemon_connected = false;
                self.rpc_client = None;
                self.event_handler = None;
                self.status_message = Some("Disconnected from daemon".to_string());
                iced::Task::none()
            }
            Message::DaemonEvent(event) => {
                tracing::debug!("Received daemon event: {:?}", event);
                self.recent_events.push(event.clone());

                // Keep only the last 100 events
                if self.recent_events.len() > 100 {
                    self.recent_events.remove(0);
                }

                // Update status
                self.status_message = Some(format!("Received event: {:?}", event.event_type));
                iced::Task::none()
            }
            Message::TimeTravel(tt_msg) => {
                time_travel::update(&mut self.time_travel_state, tt_msg);
                iced::Task::none()
            }
            Message::Debugger(dbg_msg) => {
                if let Some(_debug_command) = debugger_ui::update(&mut self.debugger_ui_state, dbg_msg) {
                    // In a real implementation, send the debug command to the daemon
                    tracing::debug!("Debugger command would be sent to daemon");
                }
                iced::Task::none()
            }
            Message::SwarmMonitor(sm_msg) => {
                swarm_monitor::update(&mut self.swarm_monitor_state, sm_msg);
                iced::Task::none()
            }
            Message::LoadSampleHistory => {
                tracing::info!("Loading sample history data");
                self.load_sample_history();
                iced::Task::none()
            }
            Message::LoadSampleSwarm => {
                tracing::info!("Loading sample swarm data");
                self.load_sample_swarm();
                iced::Task::none()
            }
            Message::ClearStatus => {
                self.status_message = None;
                iced::Task::none()
            }
            Message::ShowError(error) => {
                self.status_message = Some(format!("Error: {}", error));
                iced::Task::none()
            }
            Message::Tick => {
                // Update animation state for swarm monitor
                self.swarm_monitor_state.tick_animation();
                iced::Task::none()
            }
        }
    }

    /// Load sample swarm data for demonstration
    fn load_sample_swarm(&mut self) {
        let sample_agents = generate_sample_agents();
        self.swarm_monitor_state.agents = sample_agents;
    }

    /// Load sample history data for demonstration
    fn load_sample_history(&mut self) {
        use descartes_core::{AgentHistoryEvent, HistoryEventType, HistorySnapshot};
        use chrono::Utc;

        let base_time = Utc::now().timestamp();
        let agent_id = "demo-agent-123".to_string();

        // Create sample events
        let mut events = Vec::new();

        // Event 1: System startup
        events.push(
            AgentHistoryEvent::new(
                agent_id.clone(),
                HistoryEventType::System,
                serde_json::json!({"event": "agent_started", "version": "1.0.0"}),
            )
            .with_tags(vec!["startup".to_string()])
            .with_git_commit("abc123def456".to_string()),
        );

        // Event 2: Initial thought
        events.push(
            AgentHistoryEvent::new(
                agent_id.clone(),
                HistoryEventType::Thought,
                serde_json::json!({"content": "Analyzing task requirements", "confidence": 0.85}),
            )
            .with_tags(vec!["planning".to_string()]),
        );

        // Event 3: Tool usage
        events.push(
            AgentHistoryEvent::new(
                agent_id.clone(),
                HistoryEventType::ToolUse,
                serde_json::json!({"tool": "grep", "pattern": "TODO", "matches": 15}),
            )
            .with_tags(vec!["search".to_string()]),
        );

        // Event 4: State change
        events.push(
            AgentHistoryEvent::new(
                agent_id.clone(),
                HistoryEventType::StateChange,
                serde_json::json!({"from": "idle", "to": "working"}),
            )
            .with_tags(vec!["state_machine".to_string()]),
        );

        // Event 5: Action
        events.push(
            AgentHistoryEvent::new(
                agent_id.clone(),
                HistoryEventType::Action,
                serde_json::json!({"action": "create_file", "path": "/tmp/output.txt"}),
            )
            .with_tags(vec!["file_operation".to_string()])
            .with_git_commit("def456ghi789".to_string()),
        );

        // Event 6: Communication
        events.push(
            AgentHistoryEvent::new(
                agent_id.clone(),
                HistoryEventType::Communication,
                serde_json::json!({"type": "user_message", "content": "How is progress?"}),
            )
            .with_tags(vec!["user_interaction".to_string()]),
        );

        // Event 7: Decision
        events.push(
            AgentHistoryEvent::new(
                agent_id.clone(),
                HistoryEventType::Decision,
                serde_json::json!({"choice": "use_parallel_execution", "reasoning": "Better performance"}),
            )
            .with_tags(vec!["optimization".to_string()]),
        );

        // Event 8: Error
        events.push(
            AgentHistoryEvent::new(
                agent_id.clone(),
                HistoryEventType::Error,
                serde_json::json!({"error": "FileNotFound", "path": "/missing/file.txt"}),
            )
            .with_tags(vec!["error".to_string()]),
        );

        // Event 9: Another thought
        events.push(
            AgentHistoryEvent::new(
                agent_id.clone(),
                HistoryEventType::Thought,
                serde_json::json!({"content": "Need to handle edge case", "confidence": 0.92}),
            )
            .with_tags(vec!["problem_solving".to_string()]),
        );

        // Event 10: Final action
        events.push(
            AgentHistoryEvent::new(
                agent_id.clone(),
                HistoryEventType::Action,
                serde_json::json!({"action": "complete_task", "status": "success"}),
            )
            .with_tags(vec!["completion".to_string()])
            .with_git_commit("ghi789jkl012".to_string()),
        );

        // Adjust timestamps to be sequential
        for (i, event) in events.iter_mut().enumerate() {
            event.timestamp = base_time + (i as i64 * 60); // Events 1 minute apart
        }

        // Create a couple of snapshots
        let snapshots = vec![
            HistorySnapshot::new(
                agent_id.clone(),
                events[0..3].to_vec(),
                Some("abc123def456".to_string()),
            )
            .with_description("Initial planning phase".to_string()),
            HistorySnapshot::new(
                agent_id.clone(),
                events[0..7].to_vec(),
                Some("def456ghi789".to_string()),
            )
            .with_description("Main execution checkpoint".to_string()),
        ];

        // Update the time travel state
        time_travel::update(
            &mut self.time_travel_state,
            TimeTravelMessage::HistoryLoaded(events, snapshots),
        );
    }

    fn view(&self) -> Element<Message> {
        let header = self.view_header();
        let nav = self.view_navigation();
        let content = self.view_content();

        let main_layout = column![
            header,
            row![
                nav,
                content,
            ]
            .spacing(0)
        ]
        .spacing(0);

        container(main_layout)
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
    }

    /// Handle subscriptions (keyboard events, timers, etc.)
    fn subscription(&self) -> iced::Subscription<Message> {
        let current_view = self.current_view;

        // Timer subscription for animations (60 FPS)
        let timer_sub = iced::time::every(std::time::Duration::from_millis(16))
            .map(|_| Message::Tick);

        // Keyboard event subscription
        let keyboard_sub = iced::event::listen_with(move |event, _status, _window| {
            if let Event::Keyboard(keyboard::Event::KeyPressed {
                key,
                modifiers,
                ..
            }) = event
            {
                // Debugger keyboard shortcuts (F5, F9, F10, F11)
                if current_view == ViewMode::Debugger {
                    match key {
                        // F5: Continue
                        Key::Named(keyboard::key::Named::F5) => {
                            return Some(Message::Debugger(DebuggerMessage::KeyboardShortcut(
                                debugger_ui::DebuggerKeyboardShortcut::Continue
                            )));
                        }
                        // F9: Toggle breakpoint
                        Key::Named(keyboard::key::Named::F9) => {
                            return Some(Message::Debugger(DebuggerMessage::KeyboardShortcut(
                                debugger_ui::DebuggerKeyboardShortcut::ToggleBreakpoint
                            )));
                        }
                        // F10: Step Over
                        Key::Named(keyboard::key::Named::F10) => {
                            return Some(Message::Debugger(DebuggerMessage::KeyboardShortcut(
                                debugger_ui::DebuggerKeyboardShortcut::StepOver
                            )));
                        }
                        // F11: Step Into (or Step Out with Shift)
                        Key::Named(keyboard::key::Named::F11) => {
                            if modifiers.shift() {
                                return Some(Message::Debugger(DebuggerMessage::KeyboardShortcut(
                                    debugger_ui::DebuggerKeyboardShortcut::StepOut
                                )));
                            } else {
                                return Some(Message::Debugger(DebuggerMessage::KeyboardShortcut(
                                    debugger_ui::DebuggerKeyboardShortcut::StepInto
                                )));
                            }
                        }
                        _ => {}
                    }
                }

                // Time travel keyboard shortcuts (arrow keys, space, etc.)
                match key {
                    // Arrow keys for navigation
                    Key::Named(keyboard::key::Named::ArrowLeft) => {
                        return Some(Message::TimeTravel(TimeTravelMessage::PrevEvent));
                    }
                    Key::Named(keyboard::key::Named::ArrowRight) => {
                        return Some(Message::TimeTravel(TimeTravelMessage::NextEvent));
                    }
                    // Space bar for play/pause
                    Key::Character(ref c) if c == " " => {
                        return Some(Message::TimeTravel(TimeTravelMessage::TogglePlayback));
                    }
                    // +/- for zoom
                    Key::Character(ref c) if c == "+" || c == "=" => {
                        return Some(Message::TimeTravel(TimeTravelMessage::ZoomIn));
                    }
                    Key::Character(ref c) if c == "-" => {
                        return Some(Message::TimeTravel(TimeTravelMessage::ZoomOut));
                    }
                    // Number keys for speed control
                    Key::Character(ref c) if c == "1" => {
                        return Some(Message::TimeTravel(TimeTravelMessage::SetPlaybackSpeed(0.5)));
                    }
                    Key::Character(ref c) if c == "2" => {
                        return Some(Message::TimeTravel(TimeTravelMessage::SetPlaybackSpeed(1.0)));
                    }
                    Key::Character(ref c) if c == "3" => {
                        return Some(Message::TimeTravel(TimeTravelMessage::SetPlaybackSpeed(2.0)));
                    }
                    Key::Character(ref c) if c == "4" => {
                        return Some(Message::TimeTravel(TimeTravelMessage::SetPlaybackSpeed(5.0)));
                    }
                    // L for loop toggle
                    Key::Character(ref c) if c == "l" && !modifiers.shift() => {
                        return Some(Message::TimeTravel(TimeTravelMessage::ToggleLoop));
                    }
                    _ => {}
                }
            }
            None
        });

        // Event stream subscription (when connected)
        let event_sub = if self.daemon_connected && self.event_handler.is_some() {
            // Create event subscription using the event handler
            let event_handler_arc = self.event_handler.as_ref().unwrap().clone();

            iced::subscription::channel(
                "daemon_events",
                100,
                move |mut output| {
                    let event_handler_arc = event_handler_arc.clone();
                    async move {
                        // This is a simplified subscription - in a real implementation,
                        // we would properly integrate with the EventHandler's subscription system
                        tracing::info!("Event subscription active");

                        // Keep the subscription alive
                        loop {
                            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
                        }
                    }
                },
            )
        } else {
            iced::Subscription::none()
        };

        iced::Subscription::batch(vec![timer_sub, keyboard_sub, event_sub])
    }

    /// Render the header bar
    fn view_header(&self) -> Element<Message> {
        let title = text("Descartes GUI")
            .size(24)
            .width(Length::Shrink);

        let status_color = if self.daemon_connected {
            iced::Color::from_rgb8(100, 255, 100) // Green
        } else {
            iced::Color::from_rgb8(255, 100, 100) // Red
        };

        let status_text = if self.daemon_connected {
            "Connected"
        } else {
            "Disconnected"
        };

        let status_indicator = row![
            text("●").size(16).style(status_color),
            Space::with_width(5),
            text(format!("Daemon: {}", status_text)).size(14),
        ]
        .align_y(Vertical::Center);

        let connect_button = if self.daemon_connected {
            button(text("Disconnect"))
                .on_press(Message::DisconnectDaemon)
                .padding(8)
        } else {
            button(text("Connect"))
                .on_press(Message::ConnectDaemon)
                .padding(8)
        };

        // Show error or status message
        let message_display = if let Some(ref error) = self.connection_error {
            text(format!("Error: {}", error))
                .size(12)
                .style(iced::Color::from_rgb8(255, 150, 150))
        } else if let Some(ref msg) = self.status_message {
            text(msg)
                .size(12)
                .style(iced::Color::from_rgb8(200, 200, 200))
        } else {
            text("")
        };

        let header_content = column![
            row![
                title,
                Space::with_width(Length::Fill),
                status_indicator,
                Space::with_width(20),
                connect_button,
            ]
            .spacing(10)
            .align_y(Vertical::Center),
            if self.connection_error.is_some() || self.status_message.is_some() {
                container(message_display).padding(5)
            } else {
                container(text(""))
            },
        ]
        .spacing(5);

        container(header_content)
            .width(Length::Fill)
            .padding(15)
            .style(|theme: &Theme| {
                container::Style {
                    background: Some(theme.palette().background.into()),
                    border: iced::Border {
                        width: 0.0,
                        color: iced::Color::TRANSPARENT,
                        radius: 0.0.into(),
                    },
                    ..Default::default()
                }
            })
            .into()
    }

    /// Render the navigation sidebar
    fn view_navigation(&self) -> Element<Message> {
        let nav_items = vec![
            (ViewMode::Dashboard, "Dashboard"),
            (ViewMode::TaskBoard, "Task Board"),
            (ViewMode::SwarmMonitor, "Swarm Monitor"),
            (ViewMode::Debugger, "Debugger"),
            (ViewMode::DagEditor, "DAG Editor"),
            (ViewMode::ContextBrowser, "Context Browser"),
        ];

        let buttons: Vec<Element<Message>> = nav_items
            .into_iter()
            .map(|(view, label)| {
                let is_active = self.current_view == view;
                let btn = button(
                    text(label)
                        .size(16)
                        .width(Length::Fill)
                        .align_x(Horizontal::Center)
                )
                .width(Length::Fill)
                .padding(15)
                .on_press(Message::SwitchView(view));

                if is_active {
                    container(btn)
                        .style(|theme: &Theme| {
                            container::Style {
                                background: Some(theme.palette().primary.into()),
                                ..Default::default()
                            }
                        })
                        .into()
                } else {
                    btn.into()
                }
            })
            .collect();

        let nav_column = column(buttons)
            .spacing(5)
            .padding(10);

        container(nav_column)
            .width(200)
            .height(Length::Fill)
            .style(|theme: &Theme| {
                container::Style {
                    background: Some(theme.palette().background.into()),
                    border: iced::Border {
                        width: 1.0,
                        color: theme.palette().text.scale_alpha(0.2),
                        radius: 0.0.into(),
                    },
                    ..Default::default()
                }
            })
            .into()
    }

    /// Render the main content area
    fn view_content(&self) -> Element<Message> {
        let content = match self.current_view {
            ViewMode::Dashboard => self.view_dashboard(),
            ViewMode::TaskBoard => self.view_task_board(),
            ViewMode::SwarmMonitor => self.view_swarm_monitor(),
            ViewMode::Debugger => self.view_debugger(),
            ViewMode::DagEditor => self.view_dag_editor(),
            ViewMode::ContextBrowser => self.view_context_browser(),
        };

        container(content)
            .width(Length::Fill)
            .height(Length::Fill)
            .padding(20)
            .into()
    }

    /// Dashboard view
    fn view_dashboard(&self) -> Element<Message> {
        let title = text("Dashboard")
            .size(32)
            .width(Length::Fill);

        let welcome = text("Welcome to Descartes!")
            .size(18)
            .width(Length::Fill);

        // Connection status section
        let connection_status = if self.daemon_connected {
            column![
                text("Status: Connected to daemon").size(14).style(iced::Color::from_rgb8(100, 255, 100)),
                Space::with_height(5),
                text(format!("Recent events: {}", self.recent_events.len())).size(12),
            ]
            .spacing(5)
        } else {
            column![
                text("Status: Not connected").size(14).style(iced::Color::from_rgb8(255, 150, 150)),
                Space::with_height(5),
                text("Click 'Connect' in the top right to connect to the daemon").size(12),
            ]
            .spacing(5)
        };

        // Recent events section
        let recent_events_section = if !self.recent_events.is_empty() {
            let event_list: Vec<Element<Message>> = self.recent_events
                .iter()
                .rev()
                .take(5)
                .map(|event| {
                    text(format!("• {:?}: {}", event.event_type,
                        event.data.get("message")
                            .and_then(|v| v.as_str())
                            .unwrap_or("No message")))
                        .size(12)
                        .into()
                })
                .collect();

            column![
                Space::with_height(20),
                text("Recent Events:").size(16),
                Space::with_height(10),
                column(event_list).spacing(5),
            ]
            .spacing(5)
        } else {
            column![]
        };

        let description = text(
            "This is the Descartes GUI - a native interface for managing your AI agent workflows.\n\n\
             Phase 3.4: Basic Layout and GUI Launch - Complete\n\n\
             Features:\n\
             - Real-time task monitoring (Task Board)\n\
             - Agent swarm visualization (Swarm Monitor)\n\
             - Interactive debugger with time-travel (Debugger)\n\
             - Visual DAG editor (DAG Editor)\n\
             - Context browser (Context Browser)\n\n\
             Navigate using the sidebar to explore different views."
        )
        .size(14)
        .width(Length::Fill);

        column![
            title,
            Space::with_height(20),
            welcome,
            Space::with_height(20),
            connection_status,
            recent_events_section,
            Space::with_height(20),
            description,
        ]
        .spacing(10)
        .into()
    }

    /// Task Board view (placeholder)
    fn view_task_board(&self) -> Element<Message> {
        let title = text("Task Board")
            .size(32)
            .width(Length::Fill);

        let placeholder = text("Task Board view will display active tasks in a Kanban layout.")
            .size(16)
            .width(Length::Fill);

        column![
            title,
            Space::with_height(20),
            placeholder,
        ]
        .spacing(10)
        .into()
    }

    /// Swarm Monitor view
    fn view_swarm_monitor(&self) -> Element<Message> {
        // Add a button to load sample swarm if no agents are loaded
        if self.swarm_monitor_state.agents.is_empty() {
            let title = text("Swarm Monitor")
                .size(32)
                .width(Length::Fill);

            let load_sample_btn = button(text("Load Sample Swarm"))
                .on_press(Message::LoadSampleSwarm)
                .padding(10);

            let description = text(
                "Swarm Monitor visualizes active agents and their status in real-time.\n\n\
                Features:\n\
                - Visual agent cards with status indicators\n\
                - Real-time 'Thinking' state visualization with animations\n\
                - Progress bars for running agents\n\
                - Filtering by status (Active, Running, Thinking, etc.)\n\
                - Grouping by status or model backend\n\
                - Search agents by name or task\n\
                - Agent statistics panel\n\
                - Detailed agent view with timeline\n\n\
                Load sample data to see the interface in action."
            )
            .size(14)
            .width(Length::Fill);

            return column![
                title,
                Space::with_height(20),
                description,
                Space::with_height(20),
                load_sample_btn,
            ]
            .spacing(10)
            .into();
        }

        // Map swarm monitor messages to main messages
        swarm_monitor::view(&self.swarm_monitor_state).map(Message::SwarmMonitor)
    }

    /// Debugger view with debugger UI and time travel
    fn view_debugger(&self) -> Element<Message> {
        let title = text("Agent Debugger")
            .size(32)
            .width(Length::Fill);

        // Debugger UI (main debugger controls and views)
        let debugger_view = debugger_ui::view(&self.debugger_ui_state)
            .map(Message::Debugger);

        // Time travel section (for history navigation)
        let time_travel_section = if !self.time_travel_state.events.is_empty() {
            column![
                Space::with_height(20),
                text("Time Travel History").size(18),
                Space::with_height(10),
                time_travel::view(&self.time_travel_state).map(Message::TimeTravel),
            ]
            .spacing(5)
        } else {
            column![
                Space::with_height(20),
                button(text("Load Sample History"))
                    .on_press(Message::LoadSampleHistory)
                    .padding(10),
            ]
            .spacing(5)
        };

        column![
            title,
            Space::with_height(10),
            debugger_view,
            time_travel_section,
        ]
        .spacing(10)
        .into()
    }

    /// DAG Editor view (placeholder)
    fn view_dag_editor(&self) -> Element<Message> {
        let title = text("DAG Editor")
            .size(32)
            .width(Length::Fill);

        let placeholder = text(
            "Visual DAG editor for designing agent workflows.\n\n\
             Features coming soon:\n\
             - Drag-and-drop node creation\n\
             - Visual connection between tasks\n\
             - Template library\n\
             - Real-time validation\n\
             - Export to YAML/JSON"
        )
        .size(16)
        .width(Length::Fill);

        column![
            title,
            Space::with_height(20),
            placeholder,
        ]
        .spacing(10)
        .into()
    }

    /// Context Browser view (placeholder)
    fn view_context_browser(&self) -> Element<Message> {
        let title = text("Context Browser")
            .size(32)
            .width(Length::Fill);

        let placeholder = text(
            "Browse and manage agent execution context.\n\n\
             Features coming soon:\n\
             - View current agent state\n\
             - Browse variable bindings\n\
             - Inspect memory contents\n\
             - Search through context history\n\
             - Export context snapshots"
        )
        .size(16)
        .width(Length::Fill);

        column![
            title,
            Space::with_height(20),
            placeholder,
        ]
        .spacing(10)
        .into()
    }
}
